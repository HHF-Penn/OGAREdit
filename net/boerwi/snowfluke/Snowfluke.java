package net.boerwi.snowfluke;

import java.util.Iterator;
import java.util.Random;
import java.time.Instant;

/**
 * Utility class for Snowfluke, a long-based UID format based on "Snowflake ID". <br>
 * Bit Format: <br>
 * [0-7] Prior IDs this second. First ID generated in a second has '0' value. <br>
 * [8-21] Generator ID. All IDs generated by this generator have the same (random) value. <br>
 * [22-63] Seconds since the Unix Epoch. <br>
 */
public abstract class Snowfluke{
	private Snowfluke(){}
	final static Random rand = new Random();
	/**
	 * Gets a Snowfluke iterator. Rate-limited to 256 calls per second.
	 * @return An unlimited Snowfluke generator.
	 */
	public static Iterator<Long> getGenerator(){
		return new SnowflukeGenerator(rand.nextLong());
	}
	/**
	 * Extracts the 'seconds since epoch' from the given snowfluke ID.
	 * @param snowfluke The target ID
	 * @return The seconds since the Unix Epoch when the given ID was generated.
	 */
	public static long getEpoch(long snowfluke){
		return snowfluke >>> 22;
	}
	/**
	 * Extracts the 'generator id' from the given snowfluke ID.
	 * @param snowfluke The target ID
	 * @return The random ID of the generator of this UID.
	 */
	public static long getId(long snowfluke){
		return (snowfluke >>> 8) & 16383l;
	}
	/**
	 * Extracts the 'calls this second' from the given snowfluke ID.
	 * @param snowfluke The target ID
	 * @return The number of UIDs generated before this one in that second.
	 */
	public static long getCallsThisSec(long snowfluke){
		return snowfluke & 255l;
	}
	/**
	 * Human-readable printout for the given snowfluke ID.
	 * @param snowfluke The target ID.
	 * @return The string representation.
	 */
	public static String toString(long snowfluke){
		String date = Instant.ofEpochSecond(getEpoch(snowfluke)).toString();
		return String.format("{id:%d, ctime: \"%s\"}", snowfluke, date);
	}
}
class SnowflukeGenerator implements Iterator<Long>{
	/** This generator's ID */
	private final long id;
	/** The last second when a UID was generated. */
	private long lastSec = 0;
	/** The number of IDs that have already been generated this second. */
	private long callsThisSec = 0;
	/** Creates a SnowflukeGenerator.
	 * @param id The ID for the new generator.
	 */
	SnowflukeGenerator(long id){
		//id is 14bits, shifted 8 bits left
		this.id = (id&16383l)<<8;
	}
	/** Iterator function.
	 * @return True.
	 */
	public boolean hasNext(){
		return true;
	}
	/** Generates a new unique Snowfluke ID.
	 * @return The generated UID.
	 */
	public synchronized Long next(){
		long secEpoch = System.currentTimeMillis()/(long)1000;
		if(secEpoch != lastSec){
			lastSec = secEpoch;
			callsThisSec = 0;
		}
		long ret = 0;
		// [0-7] call this second
		ret |= callsThisSec;
		// [8-21] generator id
		ret |= id;
		// [22-63] second since epoch
		ret |= secEpoch << 22;
		// Constrain to lowest 8 bits
		callsThisSec++;
		if(callsThisSec >= 256){
			// We are out of ids, so force to wait.
			try{
				Thread.sleep(1200);
			}catch(InterruptedException e){
				assert false;
			}
		}
		// System.out.println("Snowfluke: "+ret+" Epoch Time: "+Snowfluke.getEpoch(ret)+" GeneratorId: "+Snowfluke.getId(ret)+" CallsThisSecond: "+Snowfluke.getCallsThisSec(ret));
		return ret;
	}
}
